## 406. 根据身高重建队列
> **知识点：贪心**
### 题目描述

假设有打乱顺序的一群人站成一个队列，数组 people 表示队列中一些人的属性（不一定按顺序）。每个 people[i] = [hi, ki] 表示第 i 个人的身高为 hi ，前面 正好 有 ki 个身高大于或等于 hi 的人。

请你重新构造并返回输入数组 people 所表示的队列。返回的队列应该格式化为数组 queue ，其中 queue[j] = [hj, kj] 是队列中第 j 个人的属性（queue[0] 是排在队列前面的人）。

##### 示例

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。

输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]

```
---
### 解法一：贪心

在遇到这种数对，还涉及到排序的时候，往往会对第一个元素正向排序，第二个元素反向排序，或者反过来，能够解决问题。也就是说，**像这种有两个维度的，一般情况下一定要去想先确定好一个，然后再确定另一个**；    
所以我们可以选择贪心策略：优先身高高的people，按照k来插入。    

想一下为什么这样做：**因为比他矮的人插入的话对他没有影响**。如果插在我后面，那肯定没关系，如果插在我前面，那对我的k也没影响，我的k只关心大于等于我的。   

所以先按照身高降序排序，再按照k升序排列；为什么k要升序呢，想一下同等身高的时候，k小的一定会在k大的前面，比如[5,3]和[5,2],如果我们先插入了3这个，那3被插在索引为3的位置上了，前面有3个大于等于自己的，那2再过来的时候，就只能插在3的前面，也就是索引2的位置，那这样3前面就有4个大于等于自己的了。

```
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, new Comparator<int[]>(){
            public int compare(int[] o1, int[] o2){
                if(o2[0] != o1[0]){
                    return o2[0]-o1[0];  //按照身高降序；
                }else{
                    return o1[1]-o2[1]; //按k升序；
                }
            }
        });
        List<int[]> list = new ArrayList<>();
        for(int[] person : people){
            list.add(person[1], person);  //直接插到指定位置上就可以了；
        }
        return list.toArray(new int[list.size()][]);  //列表转数组；这个方法一定要会！
    }
}
```
