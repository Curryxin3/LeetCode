## 746. 使用最小花费爬楼梯
> **知识点：动态规划**
### 题目描述

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当你爬上一个阶梯你都要花费对应的体力值，一旦支付了相应的体力值，你就可以选择向上爬一个阶梯或者爬两个阶梯。

请你找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

##### 示例

```
输入：cost = [10, 15, 20]
输出：15
解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
输出：6
解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。
```
---
### 解法一：动态规划

这道题题目的理解就很抽象，这个题中的体力就有点类似于"买路财"的感觉。你离开第i个阶梯需要花费cost[i],离开之后可以直接走一步或者走两步；   
其次就是题目中说的到达楼顶，是要到cost的长度处，不是n-1最后一个元素处，得越过去，类似于到天花板上。 所以在创建dp数组的时候要长度为n+1,最后一个元素才为dp[n];       
再其次题目中的可以选择从下标0或者下标1开始，也就是说能自己选这两个位置作为起点。


我们先创建dp数组，首先     
- **1.确定dp数组和其下标的含义**；dp[i]表示达到下标i所需要的最小花费。
- **2.确定递推公式，即状态转移方程**；到下标i处可以由之前的状态来得到，可以从下标i-1花费cost[i-1]到下标i，也可以由下标i-2花费cost[i-2]直接走两步达到。我们要的自然就是两者中的较小那个；所以： dp[i] = min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);
- **3.dp初始化**；base case; 这道题就很容易出错，因为题目中说可以从0或者1出发，所以到达0或1的最小花费都是0，即dp[0]=dp[1]
=0;

```
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int[] dp = new int[cost.length+1];
        dp[0] = 0;
        dp[1] = 0;
        for(int i = 2; i < dp.length; i++){
            dp[i] = Math.min(dp[i-1]+cost[i-1], dp[i-2]+cost[i-2]);
        }
        return dp[dp.length-1];
    }
}
```

